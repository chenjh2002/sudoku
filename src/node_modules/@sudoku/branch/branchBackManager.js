import { strategyGrid } from '@sudoku/stores/grid';
import { strategyManager } from '@sudoku/strategy/strategyManager'
import {get, writable} from 'svelte/store';

function CreateBranchBackManager() {
  let branchBackTimeSteps = [];
  const branchBackTimes = writable(0);

  return {
    getBranchBackTimes: () => branchBackTimes,

    getBranchBackTimeSteps: () => branchBackTimeSteps,

    resetBranchBackSteps: () => branchBackTimeSteps = [],

    addBranchBackTimeStep: (timeStep) => {
      branchBackTimeSteps[get(branchBackTimes)] = timeStep;
    },

    branchBackToLastBranchTimeStep: () => {
      strategyGrid.setTimeStep(get(branchBackTimes) === 0 ? 0 : branchBackTimeSteps[get(branchBackTimes) - 1]);
      strategyGrid.getStrategyGrid().update($strategyGrid => {
        $strategyGrid.map(row =>
            row.map(cell =>
                cell.branchBack(get(branchBackTimes) === 0 ? 0 : branchBackTimeSteps[get(branchBackTimes) - 1])));
        return $strategyGrid;
      })
      strategyGrid.updateCellCandidates();

      strategyManager.getIsUsingStrategy().set(true);
      branchBackTimes.update(val => val - 1);
    },

    branchBackToLastTimeStep: () => {
      strategyGrid.setTimeStep(get(strategyGrid.getTimeStep()) - 1);
      const branchBackTimeStep = get(strategyGrid.getTimeStep());

      strategyGrid.getStrategyGrid().update($strategyGrid => {
        $strategyGrid.map(row =>
            row.map(cell => cell.branchBack(branchBackTimeStep)));

        return $strategyGrid;
      })
      strategyGrid.updateCellCandidates();

      // Update branch back time steps
      if (branchBackTimeSteps.length > 0 && branchBackTimeStep <= branchBackTimeSteps[get(branchBackTimes) - 1]) {
        branchBackTimes.update(val => val - 1);
      } else if (branchBackTimeSteps.length > 0 && branchBackTimeStep === branchBackTimeSteps[branchBackTimeSteps.length - 1]) {
        strategyManager.getIsUsingStrategy().set(true);
      }
    }
  }
}

export const branchBackManager = CreateBranchBackManager();