import { hs } from '@sudoku/strategy/hiddenSingleStrategy';
import { np } from '@sudoku/strategy/nakedPairsStrategy';
import { hints } from '@sudoku/stores/hints';
import {writable} from 'svelte/store';


function CreateStrategyManager() {
  const strategiesSet = [];
  const isUsingStrategy = writable(false);
  function determineEffectiveStrategy(grid, strategyApplyCell) {
    let hasChange = false;
    for (const { strategy, _ } of strategiesSet) {
      if (strategy.preCondition(grid)) {
        strategy.apply(grid, strategyApplyCell);
        hasChange = true;
      }
    }

    return hasChange;
  }

  return {
    addNewStrategy: (strategy, priority) => {
      strategiesSet.push({strategy: strategy, priority: priority});
      strategiesSet.sort((a, b) => a.priority - b.priority);
    },

    apply: (grid, timeStep) => {
      // Reset the relative position
      grid.map(row => row.map(cell => { cell.resetRelativePos(); cell.resetStrategies(); }));

      // Increase time step
      const strategyApplyCell = [];
      while (determineEffectiveStrategy(grid, strategyApplyCell)) {}

      if (strategyApplyCell.length > 0) {
        hints.useHint();
      }
      return strategyApplyCell;
    },

    getIsUsingStrategy: () => {
      return {
        subscribe: isUsingStrategy.subscribe,

        set(val) {
          isUsingStrategy.set(val);
        },

        reset() {
          isUsingStrategy.set(false);
        }
      }
    },
  }
}

export const strategyManager = CreateStrategyManager();
strategyManager.addNewStrategy(hs, hs.priority);
strategyManager.addNewStrategy(np, np.priority);