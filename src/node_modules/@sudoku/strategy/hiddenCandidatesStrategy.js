import { BaseStrategy } from '@sudoku/strategy/baseStrategy';
import { SUDOKU_SIZE, BOX_SIZE } from '@sudoku/constants';

class HiddenPairStrategy extends BaseStrategy {
  constructor(description = "Hidden Pair", priority = 0) {
    super();
    this.description = description;
    this.priority = priority;
    this.fullSetCandidates = Array.from({ length: SUDOKU_SIZE }).map((_, i) => i + 1);
  }

  preCondition(grid) {
    // 仅检查九宫格中的隐藏双数组
    for (let row = 0; row < SUDOKU_SIZE; row += BOX_SIZE) {
      for (let col = 0; col < SUDOKU_SIZE; col += BOX_SIZE) {
        // 检查当前九宫格是否有隐藏对
        let boxCandidates = [];
        let boxCells = [];
        for (let i = row; i < row + BOX_SIZE; i++) {
          for (let j = col; j < col + BOX_SIZE; j++) {
            if (!grid[i][j].isCellConstant()) {
              boxCandidates.push(...grid[i][j].candidates);
              boxCells.push({
                x: j,  // 单元格的列索引
                y: i,  // 单元格的行索引
                candidates: grid[i][j].candidates // 存储单元格的候选数字
              });
            }
          }
        }

        // 统计候选数字的出现次数
        let candidateCounts = this.getCandidateCounts(boxCandidates);
        let hiddenPairs = this.findHiddenPairs(candidateCounts, boxCandidates, boxCells);

        let int_hiddenPairs = hiddenPairs.map(item => parseInt(item));
        let candidatesWithTwoOccurrences = Object.keys(candidateCounts).filter(candidate => candidateCounts[candidate] === 2);
        let boxCells_candidatesWithTwoOccurrences = boxCells.filter(cell => candidatesWithTwoOccurrences.every(candidate => cell.candidates.includes(parseInt(candidate))))
        // flag定义为候选框中是否仅剩隐藏双数组的标志
        let flag = 0
        for (let boxCell_candidatesWithTwoOccurrences of boxCells_candidatesWithTwoOccurrences){
            if (JSON.stringify(boxCell_candidatesWithTwoOccurrences.candidates) === JSON.stringify(int_hiddenPairs)){
                flag = flag + 1
            }
        }
        // 如果找到了隐藏对，返回true
        if (hiddenPairs.length > 0 && flag != 2) {
            return true;
        }
      }
    }
    return false;
  }

  apply(grid, strategyApplyCell) {
    // 仅在九宫格中应用隐藏双数组
    for (let row = 0; row < SUDOKU_SIZE; row += BOX_SIZE) {
      for (let col = 0; col < SUDOKU_SIZE; col += BOX_SIZE) {
        let boxCandidates = [];
        let boxCells = [];
        let relativePos = [];
        for (let i = row; i < row + BOX_SIZE; i++) {
          for (let j = col; j < col + BOX_SIZE; j++) {
            if (!grid[i][j].isCellConstant()) {
              relativePos.push({x: j, y: i})
              boxCandidates.push(...grid[i][j].candidates);
              boxCells.push({
                x: j,  // 单元格的列索引
                y: i,  // 单元格的行索引
                candidates: grid[i][j].candidates // 存储单元格的候选数字
              });
            }
          }
        }
        // 统计候选数字的出现次数
        let candidateCounts = this.getCandidateCounts(boxCandidates);
        let hiddenPairs = this.findHiddenPairs(candidateCounts, boxCandidates, boxCells);
        
        if (hiddenPairs.length > 0) {
          // 仅保留属于隐藏对的候选数字
          let hiddenPairsAxis = this.removeNonHiddenPairCandidatesForBox(grid, hiddenPairs, boxCells);
          let newRelativePos = []
          let flag = 0
          for (let item of relativePos){
            for (let hiddenPairsaxis of hiddenPairsAxis){
              if (item['x'] === hiddenPairsaxis['y'] && item['y'] === hiddenPairsaxis['x']){
                flag = 1
              }
            }
            if (flag === 0){
              newRelativePos.push(item)
            }
            flag = 0
          }
          // console.log(grid['1']['8'].candidates, hiddenPairs)
          for (let axis of hiddenPairsAxis){
            strategyApplyCell.push(axis);
            grid[axis['x']][axis['y']].strategies.push(this);
            for (let relativeAxis of newRelativePos){
              grid[axis['x']][axis['y']].relativePos.push(relativeAxis);
            } 
          } 
        }
      }
    }
  }

  // 计算候选值数量
  getCandidateCounts(candidates) {
    let candidateCounts = {};
    candidates.forEach(candidate => {
      candidateCounts[candidate] = (candidateCounts[candidate] || 0) + 1;
    });
    return candidateCounts;
  }

  // 找到隐藏双数组
  findHiddenPairs(candidateCounts, boxCandidates, boxCells) {
    let hiddenPairs = [];
    
    // 找到在box中出现了两次的数字
    let candidatesWithTwoOccurrences = Object.keys(candidateCounts).filter(candidate => candidateCounts[candidate] === 2);

    if (candidatesWithTwoOccurrences.length === 2){
        let cellsContainingCandidate = boxCells.filter(cell => candidatesWithTwoOccurrences.every(candidate => cell.candidates.includes(parseInt(candidate))));
        if (cellsContainingCandidate.length === 2) {
            hiddenPairs = candidatesWithTwoOccurrences
        }
    }
    return hiddenPairs;
  }

  removeNonHiddenPairCandidatesForBox(grid, hiddenPairs, boxCells) {
    // 遍历九宫格中的每个单元格
    let hiddenPairs_axis = []
    boxCells.forEach(cell => {
      // 检查当前单元格是否包含在隐藏双数组的两个候选数字中
      if (!grid[cell.y][cell.x].isCellConstant()) {
        // 如果当前单元格的候选数字中包含隐藏对中的任一数字，则保留这些候选数字
        if (hiddenPairs.every(candidate => grid[cell.y][cell.x].candidates.includes(parseInt(candidate)))) {
          // 只保留隐藏对中的候选数字
          grid[cell.y][cell.x].candidates = grid[cell.y][cell.x].candidates.filter(candidate => hiddenPairs.includes(String(candidate)));
          hiddenPairs_axis.push({ x: cell.y, y: cell.x })
        } 
      }
    });
    return hiddenPairs_axis
  }
  
  strategyDescription() {
    return this.description;
  }
}

export const hp = new HiddenPairStrategy();
//example: 19IQlAvAHzf1C2-dVlbZkANPkRIRa