import { BaseStrategy } from '@sudoku/strategy/baseStrategy';
import { SUDOKU_SIZE, BOX_SIZE} from '@sudoku/constants';

class HiddenSingleStrategy extends BaseStrategy {
  constructor(description = "Hidden Single", priority = 1) {
    super();
    this.description = description;
    this.priority = priority;
    this.fullSetCandidates = Array.from({length: SUDOKU_SIZE}).map((_, i) => i + 1);
  }

  isSameBox(pos1, pos2) {
    return Math.floor(pos1.y / BOX_SIZE) === Math.floor(pos2.y / BOX_SIZE)
    && Math.floor(pos1.x / BOX_SIZE) === Math.floor(pos2.x / BOX_SIZE);
  }

  preCondition(grid) {
    for (let row = 0; row < SUDOKU_SIZE; row++) {
      for (let col = 0; col < SUDOKU_SIZE; col++) {
        if (grid[row][col].isCellConstant() || grid[row][col].candidates.length === 1) continue;
        // Same row filter
        let sameRowOtherCellCandidatesArray = grid[row]
            .filter((cell, index) => !cell.isCellConstant() && index !== col)
            .map(cell => cell.candidates)
            .flat();
        let sameRowOtherCellCandidatesSet = new Set(sameRowOtherCellCandidatesArray);

        let leftSameRowCandidates = grid[row][col].candidates.filter(candidate => !sameRowOtherCellCandidatesSet.has(candidate));
        if (leftSameRowCandidates.length === 1) {
          return true;
        }

        // Same col filter
        let sameColOtherCellCandidatesArray = grid
            .filter((cellRow, index) => !cellRow[col].isCellConstant() && index !== row)
            .map(cellRow => cellRow[col].candidates)
            .flat();
        let sameColOtherCellCandidatesSet = new Set(sameColOtherCellCandidatesArray);
        
        let leftSameColCandidates = grid[row][col].candidates.filter(candidate => !sameColOtherCellCandidatesSet.has(candidate));
        if (leftSameColCandidates.length === 1) {
          return true;
        }
        
        // Same box filter
        let sameBoxOtherCellCandidatesSet = new Set();
        let startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
        let startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
        for (let i = startRow; i < startRow + BOX_SIZE; i++) {
          for (let j = startCol; j < startCol + BOX_SIZE; j++) {
            if (!(i === row && j === col)  && !grid[i][j].isCellConstant()) {
             for (const candidate of grid[i][j].candidates) {
               sameBoxOtherCellCandidatesSet.add(candidate);
             }
            }
          }
        }
        let leftSameBoxCandidates = grid[row][col].candidates.filter(candidate => !sameBoxOtherCellCandidatesSet.has(candidate));
        if (leftSameBoxCandidates.length === 1) {
          return true;
        }
      }
    }


    return false;
  }

  apply(grid, strategyApplyCell) {
    for (let row = 0; row < SUDOKU_SIZE; row++) {
      for (let col = 0; col < SUDOKU_SIZE; col++) {
        if (grid[row][col].isCellConstant() || grid[row][col].candidates.length === 1) continue;

        // Same row filter
        let sameRowOtherCellCandidatesArray = grid[row]
          .filter((cell, index) => !cell.isCellConstant() && index !== col)
          .map(cell => cell.candidates)
          .flat();
        let sameRowOtherCellCandidatesSet = new Set(sameRowOtherCellCandidatesArray);

        let leftSameRowCandidates = grid[row][col].candidates.filter(candidate => !sameRowOtherCellCandidatesSet.has(candidate));
        if (leftSameRowCandidates.length === 1) {
          grid[row][col].candidates = leftSameRowCandidates;
          for (let r = 0; r < SUDOKU_SIZE; r++) {
            for (let c = 0; c < SUDOKU_SIZE; c++) {
              if (c === col) continue;
              if ((grid[r][c].isCellConstant() && grid[r][c].getCurrentCell() === leftSameRowCandidates[0])
                  || (!grid[r][c].isCellConstant() && grid[r][c].candidates.length === 1 && grid[r][c].candidates[0] === leftSameRowCandidates[0])
                ) {
                for (const strategy of grid[row][c].strategies) {
                  if (!grid[row][col].strategies.includes(strategy)) {
                    grid[row][col].strategies.push(strategy);
                  }
                }
                grid[row][col].relativePos.push({x: c, y: r});
              }
            }
          }

          for (let c = 0; c < SUDOKU_SIZE; c++) {
            if (c === col) continue;
            if (!grid[row][c].isCellConstant() && grid[row][c].strategies.length > 0
              && !grid[row][col].relativePos.some(cell => cell.x === c || this.isSameBox(cell, {x: c, y: row}))) {
              for (const strategy of grid[row][c].strategies) {
                if (!grid[row][col].strategies.includes(strategy)) {
                  grid[row][col].strategies.push(strategy);
                }
              }
              grid[row][col].relativePos.push({x: c, y: row});
            }
          }

          grid[row][col].strategies.push(this);


          strategyApplyCell.push({x: col, y: row});
          continue;
        }

        // Same col filter
        let sameColOtherCellCandidatesArray = grid
          .filter((cellRow, index) => !cellRow[col].isCellConstant() && index !== row)
          .map(cellRow => cellRow[col].candidates)
          .flat();
        let sameColOtherCellCandidatesSet = new Set(sameColOtherCellCandidatesArray);

        let leftSameColCandidates = grid[row][col].candidates.filter(candidate => !sameColOtherCellCandidatesSet.has(candidate));
        if (leftSameColCandidates.length === 1) {
          grid[row][col].candidates = leftSameColCandidates;
          grid[row][col].strategies.push(this);
          for (let r = 0; r < SUDOKU_SIZE; r++) {
            for (let c = 0; c < SUDOKU_SIZE; c++) {
              if (r === row) continue;
              if ((grid[r][c].isCellConstant() && grid[r][c].getCurrentCell() === leftSameColCandidates[0])
                  || (!grid[r][c].isCellConstant() && grid[r][c].candidates.length === 1 && grid[r][c].candidates[0] === leftSameColCandidates[0])) {
                for (const strategy of grid[row][c].strategies) {
                  if (!grid[row][col].strategies.includes(strategy)) {
                    grid[row][col].strategies.push(strategy);
                  }
                }
                grid[row][col].relativePos.push({x: c, y: r});
              }
            }
          }

          for (let r = 0; r < SUDOKU_SIZE; r++) {
            if (r === row) continue;
            if (!grid[r][col].isCellConstant() && grid[r][col].strategies.length > 0
              && !grid[row][col].relativePos.some(cell => cell.y === r || this.isSameBox(cell, {x: r, y: col}))) {
              for (const strategy of grid[r][col].strategies) {
                if (!grid[row][col].strategies.includes(strategy)) {
                  grid[row][col].strategies.push(strategy);
                }
              }
              grid[row][col].relativePos.push({x: col, y: r});
            }
          }

          grid[row][col].strategies.push(this);

          strategyApplyCell.push({x: col, y: row});
          continue;
        }

        // Same box filter
        let sameBoxOtherCellCandidatesSet = new Set();
        let startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
        let startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
        for (let i = startRow; i < startRow + BOX_SIZE; i++) {
          for (let j = startCol; j < startCol + BOX_SIZE; j++) {
            if (!(i === row && j === col)  && !grid[i][j].isCellConstant()) {
              for (const candidate of grid[i][j].candidates) {
                sameBoxOtherCellCandidatesSet.add(candidate);
              }
            }
          }
        }

        let leftSameBoxCandidates = grid[row][col].candidates.filter(candidate => !sameBoxOtherCellCandidatesSet.has(candidate));
        if (leftSameBoxCandidates.length === 1) {
          grid[row][col].candidates = leftSameBoxCandidates;
          let startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
          let startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
          for (let i = startRow; i < startRow + BOX_SIZE; i++) {
            for (let j = 0; j < SUDOKU_SIZE; j++) {
              if (i === row || j === col)  continue;
              if ((grid[i][j].isCellConstant() && grid[i][j].getCurrentCell() === leftSameBoxCandidates[0])
                  ||(!grid[i][j].isCellConstant() &&  grid[i][j].candidates.length === 1 && grid[i][j].candidates[0] === leftSameBoxCandidates[0])) {
                if (grid[i][j].strategies.length > 0) {
                  for (const strategy of grid[i][j].strategies) {
                    if (!grid[row][col].strategies.includes(strategy)) {
                      grid[row][col].strategies.push(strategy);
                    }
                  }
                }
                grid[row][col].relativePos.push({x: j, y: i});
              }
            }
          }

          for (let i = 0; i < SUDOKU_SIZE; i++) {
            for (let j = startCol; j < startCol + BOX_SIZE; j++) {
              if (i === row || j === col)  continue;
              if ((grid[i][j].isCellConstant() && grid[i][j].getCurrentCell() === leftSameBoxCandidates[0])
                  ||(!grid[i][j].isCellConstant() &&  grid[i][j].candidates.length === 1&& grid[i][j].candidates[0] === leftSameBoxCandidates[0])) {
                if (grid[i][j].strategies.length > 0) {
                  for (const strategy of grid[i][j].strategies) {
                    if (!grid[row][col].strategies.includes(strategy)) {
                      grid[row][col].strategies.push(strategy);
                    }
                  }
                }
                grid[row][col].relativePos.push({x: j, y: i});
              }
            }
          }


          grid[row][col].strategies.push(this);

          strategyApplyCell.push({x: col, y: row});
        }
      }
    }
  }

  strategyDescription() {
    return this.description;
  }
}

export const hs = new HiddenSingleStrategy();