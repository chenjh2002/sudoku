import { BaseStrategy } from '@sudoku/strategy/baseStrategy';
import { SUDOKU_SIZE, BOX_SIZE } from '@sudoku/constants';

class NakedPairsStrategy extends BaseStrategy {
    constructor(description = "Naked Pairs", priority = 2) {
        super();
        this.description = description;
        this.priority = priority;
    }

    preCondition(grid) {
        // 检查行
        for (let row = 0; row < SUDOKU_SIZE; row++) {
            if (this.checkUnitForNakedPairs(grid[row])) {
                return true;
            }
        }

        // 检查列
        for (let col = 0; col < SUDOKU_SIZE; col++) {
            const colArray = grid.map(row => row[col]);
            if (this.checkUnitForNakedPairs(colArray)) {
                return true;
            }
        }

        // 检查宫
        for (let box = 0; box < SUDOKU_SIZE; box++) {
            const boxRow = Math.floor(box / BOX_SIZE) * BOX_SIZE;
            const boxCol = (box % BOX_SIZE) * BOX_SIZE;
            const boxArray = [];

            for (let i = 0; i < BOX_SIZE; i++) {
                for (let j = 0; j < BOX_SIZE; j++) {
                    boxArray.push(grid[boxRow + i][boxCol + j]);
                }
            }

            if (this.checkUnitForNakedPairs(boxArray)) {
                return true;
            }
        }
        return false;
    }

    checkUnitForNakedPairs(unit) {
        for (let i = 0; i < unit.length - 1; i++) {
            if (unit[i].isCellConstant() || unit[i].candidates.length !== 2) {
                continue;
            }

            for (let j = i + 1; j < unit.length; j++) {
                if (unit[j].isCellConstant() || unit[j].candidates.length !== 2) continue;

                const candidates = unit[i].candidates;
                if (this.arraysEqual(unit[i].candidates, unit[j].candidates)) {
                    for (let k = 0; k < unit.length; k++) {
                        // 如果k不等于i和j且k的candidates和i的candidates有交集
                        if (k !== i && k !== j && !unit[k].isCellConstant() && unit[k].candidates.some(n => candidates.includes(n))) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    apply(grid, strategyApplyCell) {
        // 应用到行
        for (let row = 0; row < SUDOKU_SIZE; row++) {
            this.applyToUnit(grid[row], row, true, grid, strategyApplyCell);
        }

        // 应用到列
        for (let col = 0; col < SUDOKU_SIZE; col++) {
            const colArray = grid.map(row => row[col]);
            this.applyToUnit(colArray, col, false, grid, strategyApplyCell);
        }

        // 应用到宫
        for (let box = 0; box < SUDOKU_SIZE; box++) {
            const boxRow = Math.floor(box / BOX_SIZE) * BOX_SIZE;
            const boxCol = (box % BOX_SIZE) * BOX_SIZE;
            const boxArray = [];

            for (let i = 0; i < BOX_SIZE; i++) {
                for (let j = 0; j < BOX_SIZE; j++) {
                    boxArray.push({
                        cell: grid[boxRow + i][boxCol + j],
                        row: boxRow + i,
                        col: boxCol + j
                    });
                }
            }

            this.applyToBox(boxArray, grid, strategyApplyCell);
        }
    }

    applyToUnit(unit, index, isRow, grid, strategyApplyCell) {
        for (let i = 0; i < unit.length - 1; i++) {
            if (unit[i].isCellConstant() || unit[i].candidates.length !== 2) continue;

            for (let j = i + 1; j < unit.length; j++) {
                if (unit[j].isCellConstant() || unit[j].candidates.length !== 2) continue;

                if (this.arraysEqual(unit[i].candidates, unit[j].candidates)) {
                    const candidates = unit[i].candidates;
                    // // 把位置和候选数打印出来
                    // console.log('location: ', isRow ? {x: i, y: index} : {x: index, y: i});
                    // console.log('index: ', index);
                    // console.log('i, j: ', i, j);
                    // console.log('unit[i].candidates: ', unit[i].candidates);
                    // console.log('unit[j].candidates: ', unit[j].candidates);

                    // 从其他单元格移除这些候选数
                    for (let k = 0; k < unit.length; k++) {
                        if (k !== i && k !== j && !unit[k].isCellConstant()) {
                            const originalLength = unit[k].candidates.length;
                            // 只看location: {x: 8, y: 4}且candidates.length === 2的单元格
                            // if (isRow ? (k === 8 && index === 0) : (index === 8 && k === 0)) {
                            //     console.log('location: ', isRow ? {x: k, y: index} : {x: index, y: k});
                            //     console.log('unit[k].candidates: ', unit[k].candidates);
                            //     debugger;
                            // }
                            unit[k].candidates = unit[k].candidates.filter(n => !candidates.includes(n));
                            // if (isRow ? (k === 8 && index === 0) : (index === 8 && k === 0)) {
                            //     console.log('unit[k].candidates: ', unit[k].candidates);
                            //     debugger;
                            // }

                            if (originalLength !== unit[k].candidates.length) {
                                const pos = isRow ? {x: k, y: index} : {x: index, y: k};
                                // // 只有当unit[k].candidates.length === 1时才添加到strategyApplyCell
                                // if (unit[k].candidates.length === 1) {
                                //     strategyApplyCell.push(pos);
                                // }
                                strategyApplyCell.push(pos);
                                // unit[k].strategies.push(this);

                                // 添加相关的位置
                                unit[k].relativePos.push(isRow ? {x: i, y: index} : {x: index, y: i});
                                unit[k].relativePos.push(isRow ? {x: j, y: index} : {x: index, y: j});
                            }
                        }
                    }
                }
            }
        }
    }

    applyToBox(boxArray, grid, strategyApplyCell) {
        for (let i = 0; i < boxArray.length - 1; i++) {
            if (boxArray[i].cell.isCellConstant() || boxArray[i].cell.candidates.length !== 2) continue;

            for (let j = i + 1; j < boxArray.length; j++) {
                if (boxArray[j].cell.isCellConstant() || boxArray[j].cell.candidates.length !== 2) continue;

                if (this.arraysEqual(boxArray[i].cell.candidates, boxArray[j].cell.candidates)) {
                    const candidates = boxArray[i].cell.candidates;
                    // // 把位置和候选数打印出来
                    // console.log('location: ', {x: boxArray[i].col, y: boxArray[i].row});
                    // console.log('i, j: ', i, j);
                    // console.log('boxArray[i].cell.candidates: ', boxArray[i].cell.candidates);
                    // console.log('boxArray[j].cell.candidates: ', boxArray[j].cell.candidates);

                    // 从宫内其他单元格移除这些候选数
                    for (let k = 0; k < boxArray.length; k++) {
                        if (k !== i && k !== j && !boxArray[k].cell.isCellConstant()) {
                            const originalLength = boxArray[k].cell.candidates.length;
                            // 只看location: {x: 8, y: 0}的单元格
                            // if (boxArray[k].col === 8 && boxArray[k].row === 0) {
                            //     console.log('location: ', {x: boxArray[k].col, y: boxArray[k].row});
                            //     console.log('boxArray[k].cell.candidates: ', boxArray[k].cell.candidates);
                            //     debugger;
                            // }
                            boxArray[k].cell.candidates = boxArray[k].cell.candidates.filter(n => !candidates.includes(n));
                            // if (boxArray[k].col === 8 && boxArray[k].row === 0) {
                            //     console.log('boxArray[k].cell.candidates: ', boxArray[k].cell.candidates);
                            //     debugger;
                            // }

                            if (originalLength !== boxArray[k].cell.candidates.length) {
                                strategyApplyCell.push({x: boxArray[k].col, y: boxArray[k].row});
                                // // 只有当boxArray[k].cell.candidates里只有一个元素时才添加到strategyApplyCell
                                // if (boxArray[k].cell.candidates.length === 1) {
                                //     strategyApplyCell.push({x: boxArray[k].col, y: boxArray[k].row});
                                // }
                                // boxArray[k].cell.strategies.push(this);
                                // 添加相对位置
                                boxArray[k].cell.relativePos.push({x: boxArray[i].col, y: boxArray[i].row});
                                boxArray[k].cell.relativePos.push({x: boxArray[j].col, y: boxArray[j].row});
                            }
                        }
                    }
                }
            }
        }
    }

    arraysEqual(a, b) {
        if (a.length !== b.length) return false;
        a.sort();
        b.sort();
        return a.every((val, index) => val === b[index]);
    }

    strategyDescription() {
        return this.description;
    }
}

export const np = new NakedPairsStrategy();