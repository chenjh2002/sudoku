import { BaseStrategy } from '@sudoku/strategy/baseStrategy';
import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';

/**
 * Pointing Pairs 策略实现
 */
export class PointingPairsStrategy extends BaseStrategy {
    constructor(description = "Pointing Pairs", priority = 3) {
        super();
        this.description = description;
        this.priority = priority;
    }

    // 判断两个单元格是否在同一个宫内
    isSameBox(pos1, pos2) {
        return Math.floor(pos1.y / BOX_SIZE) === Math.floor(pos2.y / BOX_SIZE) &&
            Math.floor(pos1.x / BOX_SIZE) === Math.floor(pos2.x / BOX_SIZE);
    }

    /**
     * 检查是否满足 Pointing Pairs 策略的前置条件
     * @param grid {Array} 当前数独网格
     * @returns {boolean} 是否满足策略的应用条件
     */
    preCondition(grid) {
        // 遍历所有宫格（box）
        for (let boxRow = 0; boxRow < BOX_SIZE; boxRow++) {
            for (let boxCol = 0; boxCol < BOX_SIZE; boxCol++) {
                let candidatesByNumber = {};

                // 查找当前宫格内所有数字的候选位置
                for (let row = boxRow * BOX_SIZE; row < (boxRow + 1) * BOX_SIZE; row++) {
                    for (let col = boxCol * BOX_SIZE; col < (boxCol + 1) * BOX_SIZE; col++) {
                        if (grid[row][col].isCellConstant()) continue; // 跳过常量单元格

                        // 对每个候选数字进行统计
                        for (let candidate of grid[row][col].candidates) {
                            if (!candidatesByNumber[candidate]) {
                                candidatesByNumber[candidate] = { rows: new Set(), cols: new Set() };
                            }
                            candidatesByNumber[candidate].rows.add(row);
                            candidatesByNumber[candidate].cols.add(col);
                        }
                    }
                }
                // console.log(candidatesByNumber);

                // 检查是否存在只能出现在某一行或某一列的候选数字
                for (let candidate in candidatesByNumber) {
                    let { rows, cols } = candidatesByNumber[candidate];

                    // 如果该数字只出现在当前宫格的某一行或某一列
                    if (rows.size === 1 && cols.size > 1) {
                        let thisRow = [...rows][0];
                        for (let col = 0; col < SUDOKU_SIZE; col++) {
                            if (!this.isSameBox({x: boxCol * BOX_SIZE, y: thisRow}, {x: col, y: thisRow})) {
                                if (!grid[thisRow][col].isCellConstant() && grid[thisRow][col].candidates.includes(parseInt(candidate))) {
                                    return true;//满足条件
                                }
                            }
                        }
                    }

                    if (cols.size === 1 && rows.size > 1) {
                        let thisCol = [...cols][0];
                        for (let row = 0; row < SUDOKU_SIZE; row++) {
                            if (!this.isSameBox({ x: thisCol, y: boxRow * BOX_SIZE }, { x: thisCol, y: row })) {
                                if (!grid[row][thisCol].isCellConstant() && grid[row][thisCol].candidates.includes(parseInt(candidate))) {
                                    return true;//满足条件
                                }
                            }
                        }
                    }

                }
            }
        }
        return false; // 不满足条件，不能应用策略
    }

    /**
     * 执行 Pointing Pairs 策略
     * @param grid {Array} 当前数独网格
     * @param strategyApplyCell {Array} 记录应用策略的单元格
     */
    apply(grid, strategyApplyCell) {
        // 遍历所有宫格（box）
        for (let boxRow = 0; boxRow < BOX_SIZE; boxRow++) {
            for (let boxCol = 0; boxCol < BOX_SIZE; boxCol++) {

                let candidatesByNumber = [];

                // 查找当前宫格内所有数字的候选位置
                for (let row = boxRow * BOX_SIZE; row < (boxRow + 1) * BOX_SIZE; row++) {
                    for (let col = boxCol * BOX_SIZE; col < (boxCol + 1) * BOX_SIZE; col++) {

                        if (grid[row][col].isCellConstant()) continue; // 跳过常量单元格

                        // 对每个候选数字进行统计
                        for (let candidate of grid[row][col].candidates) {
                            // console.log('candidate ', candidate);
                            if (!candidatesByNumber[candidate]) {
                                candidatesByNumber[candidate] = { rows: new Set(), cols: new Set() };
                            }
                            candidatesByNumber[candidate].rows.add(row);
                            candidatesByNumber[candidate].cols.add(col);
                            // console.log('candidatesByNumber:[candidate].rows ', candidatesByNumber[candidate].rows);
                            // console.log('candidatesByNumber:[candidate].cols ', candidatesByNumber[candidate].cols);
                        }
                    }
                }

                // console.log(candidatesByNumber); break;

                // 遍历所有候选数字（一个宫中）
                for (let candidate in candidatesByNumber) {

                    let { rows, cols } = candidatesByNumber[candidate];

                    // 如果该数字只出现在当前宫格的某一行，且不止出现在某一列
                    if (rows.size === 1 && cols.size > 1) {
                        let thisRow = [...rows][0];

                        // 对当前行的其他宫格进行排除该数字的操作
                        for (let col = 0; col < SUDOKU_SIZE; col++) {
                            if (!this.isSameBox({ x: boxCol * BOX_SIZE, y: thisRow }, { x: col, y: thisRow })) {
                                if (!grid[thisRow][col].isCellConstant() && grid[thisRow][col].candidates.includes(parseInt(candidate))) {
                                    grid[thisRow][col].candidates = grid[thisRow][col].candidates.filter(c => c !== parseInt(candidate));

                                    // console.log(grid[thisRow][col].candidates);
                                    for (const value of cols) {
                                        strategyApplyCell.push({ x: value, y: thisRow });
                                        grid[thisRow][value].relativePos.push({ x: col, y: thisRow });
                                        grid[thisRow][value].strategies.push(this);
                                    }
                                }
                            }
                        }
                    }

                    // 如果该数字只出现在当前宫格的某一列
                    if (cols.size === 1 && rows.size > 1) {
                        let thisCol = [...cols][0];

                        // 对当前列的其他宫格进行排除该数字的操作
                        for (let row = 0; row < SUDOKU_SIZE; row++) {
                            if (!this.isSameBox({ x: thisCol, y: boxRow * BOX_SIZE }, { x: thisCol, y: row })) {
                                if (!grid[row][thisCol].isCellConstant() && grid[row][thisCol].candidates.includes(parseInt(candidate))) {
                                    grid[row][thisCol].candidates = grid[row][thisCol].candidates.filter(c => c !== parseInt(candidate));
                                    for (const value of rows) {
                                        strategyApplyCell.push({ x: thisCol, y: value });
                                        grid[value][thisCol].relativePos.push({ x: thisCol, y: row });
                                        grid[value][thisCol].strategies.push(this);
                                    }
                                }
                            }
                        }
                    }
                }
            }





        }
    }

    /**
     * 策略描述
     * @returns {string} 策略描述
     */
    strategyDescription() {
        return this.description;
    }
}

export const pp = new PointingPairsStrategy();
