import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { decodeSencode, encodeSudoku } from '@sudoku/sencode';
import { generateSudoku, solveSudoku } from '@sudoku/sudoku';
import {derived, get, writable} from 'svelte/store';
import { hints } from './hints';
import { CreateCellLinkedList } from '@sudoku/stores/cell';

function createGrid() {
  const grid = writable([
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
  ]);

  return {
    subscribe: grid.subscribe,

    generate(difficulty) {
      grid.set(generateSudoku(difficulty));
    },

    decodeSencode(sencode) {
      grid.set(decodeSencode(sencode));
    },

    get(gridStore, x, y) {
      return gridStore[y][x];
    },

    getSencode(gridStore) {
      return encodeSudoku(gridStore);
    },
  };
}

export const grid = createGrid();


function createUserGrid() {
  const userGrid = writable([
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
  ]);

  grid.subscribe($grid => {
    let newGrid = [];

    for (let y = 0; y < SUDOKU_SIZE; y++) {
      newGrid[y] = [];
      for (let x = 0; x < SUDOKU_SIZE; x++) {
        newGrid[y][x] = $grid[y][x];
      }
    }

    userGrid.set(newGrid);
  });

  return {
    subscribe: userGrid.subscribe,

    set: (pos, value) => {
      userGrid.update($userGrid => {
        $userGrid[pos.y][pos.x] = value;
        return $userGrid;
      });
    },

    applyHint: (pos) => {
      hints.useHint();
      userGrid.update($userGrid => {
        const solvedSudoku = solveSudoku($userGrid);
        $userGrid[pos.y][pos.x] = solvedSudoku[pos.y][pos.x];
        return $userGrid;
      });
    },
  };
}

export const userGrid = createUserGrid();

export const invalidCells = derived(userGrid, $userGrid => {
  const _invalidCells = [];

  const addInvalid = (x, y) => {
    const xy = x + ',' + y;
    if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
  };

  for (let y = 0; y < SUDOKU_SIZE; y++) {
    for (let x = 0; x < SUDOKU_SIZE; x++) {

      const value = $userGrid[y][x];

      if (value) {
        for (let i = 0; i < SUDOKU_SIZE; i++) {
          // Check the row
          if (i !== x && $userGrid[y][i] === value) {
            addInvalid(x, y);
          }

          // Check the column
          if (i !== y && $userGrid[i][x] === value) {
            addInvalid(x, i);
          }
        }

        // Check the box
        const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
        const endY = startY + BOX_SIZE;
        const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
        const endX = startX + BOX_SIZE;
        for (let row = startY; row < endY; row++) {
          for (let col = startX; col < endX; col++) {
            if (row !== y && col !== x && $userGrid[row][col] === value) {
              addInvalid(col, row);
            }
          }
        }
      }

    }
  }

  return _invalidCells;
}, []);

/**
 *
 * @returns {{subscribe: (this:void, run: Subscriber<*[]>, invalidate?: Invalidator<*[]>) => Unsubscriber}}
 */
function createStrategyGrid() {
  const strategyGrid = writable([]);
  let timeStep = writable(0);

  grid.subscribe($grid => {
    strategyGrid.set(Array.from({length: SUDOKU_SIZE},
        (_, y) => Array.from({length: SUDOKU_SIZE},
            (_, x) => new CreateCellLinkedList({x, y}, $grid))));
  })

  return {
    subscribe: strategyGrid.subscribe,

    set: (pos, value) => {
      strategyGrid.update($strategyGrid => {
        $strategyGrid[pos.y][pos.x].explore = value;
        $strategyGrid[pos.y][pos.x].strategy = [];
        $strategyGrid[pos.y][pos.x].relativePos = [];
        $strategyGrid[pos.y][pos.x].add(get(timeStep));
        return $strategyGrid;
      });
    },

    setCurrentCell: (pos) => {
      strategyGrid.update($strategyGrid => {
        if ($strategyGrid[pos.y][pos.x].candidates.length === 1) {
          $strategyGrid[pos.y][pos.x].explore = $strategyGrid[pos.y][pos.x].candidates[0];
        }
        $strategyGrid[pos.y][pos.x].add(get(timeStep));
        return $strategyGrid;
      })
    },

    increaseTimeStep: ()=> timeStep.update($timeStep => { $timeStep++; return $timeStep;}),

    /**
     * Getter and Setter method
     */
    setTimeStep: (specificTimeStep) => timeStep.set(specificTimeStep),
    getTimeStep: () => timeStep,

    getStrategyGrid: () => strategyGrid,

    updateCellCandidates: () => {
      strategyGrid.update($strategyGrid => {
        for (let row = 0; row < SUDOKU_SIZE; row++) {
          for (let col = 0; col < SUDOKU_SIZE; col++) {
            if ($strategyGrid[row][col].isCellConstant()) continue;

            let candidates = Array.from({length: SUDOKU_SIZE}, (_, i) => i + 1);
            const sameRow = $strategyGrid[row]
              .filter((cell, index) => index !== col)
              .map(cell => cell.isCellConstant() ? cell.getCurrentCell() : 0)
              .flat();
            const sameCol = $strategyGrid
            .filter((cellRow, index) => index !== row)
            .map(cellRow => cellRow[col].isCellConstant() ? cellRow[col].getCurrentCell() : 0)
            .flat();

            // Same box
            const boxStartRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
            const boxStartCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
            const sameBox = [];
            for (let r = boxStartRow; r < boxStartRow + BOX_SIZE; r++) {
              for (let c = boxStartCol; c < boxStartCol + BOX_SIZE; c++) {
                if ($strategyGrid[r][c].isCellConstant()) sameBox.push($strategyGrid[r][c].getCurrentCell());
              }
            }

            const excludeValue = new Set([...sameRow, ...sameCol, ...sameBox]);
            candidates = candidates.filter(candidate => !excludeValue.has(candidate));
            $strategyGrid[row][col].candidates = candidates;
          }
        }

        return $strategyGrid;
      })
    }
  }
}

export const strategyGrid = createStrategyGrid();