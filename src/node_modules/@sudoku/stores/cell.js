/**
 *  Create a new current time step cell.
 * @param before {{candidates, timeStep, before, strategies, relativePos, available}|null}
 * @param timeStep {number}
 * @param available {boolean}
 * @param candidates {Number[]}
 * @param strategies {{String}[]}
 * @param relativePos {{x, y}[]}
 * @returns {{candidates, timeStep, before, strategies, relativePos, available}}
 * @constructor
 */
export function CreateCurrentTimeStepCell(
    before, timeStep, available, candidates = null, strategies = null,
    relativePos = null) {
  return {
    before: before,
    timeStep: timeStep,
    available: available,
    strategies: strategies,
    candidates: {...candidates},
    relativePos: {...relativePos},
  };
}


/**
 *
 * @param pos {{x, y}}
 * @param grid {Number[][]}
 */
export function CreateCellLinkedList(pos, grid) {
  this.timeStep = 0;
  // Calculate the candidate value
  this.currentPos = {...pos};
  this.isConstant = grid[this.currentPos.y][this.currentPos.x] !== 0;
  this.candidates = null;
  this.current = null;
  this.relativePos = [];

  /**
   * Return available of the grid.
   */
  const isCellConstant = () => {
    return this.isConstant;
  };

  const getInitialCandidate = (row, col) => {
    let candidates = Array.from({length: SUDOKU_SIZE}, (_, i) => i + 1);
    const sameRow = grid[row];
    const sameCol = grid.map(row => row[col]);

    // Same box
    const boxStartRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
    const boxStartCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
    const sameBox = [];
    for (let r = boxStartRow; r < boxStartRow + BOX_SIZE; r++) {
      for (let c = boxStartCol; c < boxStartCol + BOX_SIZE; c++) {
        sameBox.push(grid[r][c]);
      }
    }

    const excludeValue = new Set([...sameRow, ...sameCol, ...sameBox]);
    candidates = candidates.filter(candidate => !excludeValue.has(candidate));
    return candidates;
  };

  if (!this.isConstant) {
    this.candidates = getInitialCandidate(this.currentPos.y, this.currentPos.x);
    this.current = CreateCurrentTimeStepCell(null, this.timeStep, true,
        this.candidates);
  }

  /**
   * Return candidates at current time step
   * @returns {Number|number|*}
   */
  const getCurrentValue = () => {
    if (this.isConstant) {
      return grid[this.currentPos.y][this.currentPos.x];
    }

    return this.current.candidates;
  };

  /**
   * Return relative position at current time step
   * @returns {any}
   */
  const getRelativePos = function() {
    return this.relativePos;
  };

  /**
   * Add a new state when strategies work/ decision make
   * @param newTimeStep
   * @param strategies
   */
  const add = (newTimeStep, strategies) => {
    this.timeStep = newTimeStep;
    this.current = CreateCurrentTimeStepCell(this.current, this.timeStep,
        this.candidates.length !== 1, this.candidates, strategies,
        this.relativePos);
    this.relativePos = null;
  };

  /**
   * Return to the branch point
   * @param specificTimeStep
   */
  const branchBack = (specificTimeStep) => {
    if (specificTimeStep < 0) {
      throw new Error('time step must bigger than zero');
    }

    if (this.isConstant) {
      return;
    }

    while (this.current.timeStep > specificTimeStep) {
      this.current = this.current.before;
    }
  };
}