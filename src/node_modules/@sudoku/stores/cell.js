import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
/**
 *  Create a new current time step cell.
 * @param before {{candidates, timeStep, before, strategies, relativePos, available}|null}
 * @param timeStep {number}
 * @param available {boolean}
 * @param candidates {Number[]}
 * @param strategies {{description}[]}
 * @param relativePos {{x, y}[]}
 * @param explore {Number}
 * @returns {{candidates, timeStep, before, strategies, relativePos, available}}
 * @constructor
 */
export function CreateCurrentTimeStepCell(
    before, timeStep, available, candidates = null, strategies = null,
    relativePos = null, explore = 0) {
  return {
    before: before,
    timeStep: timeStep,
    available: available,
    strategies: strategies === null ? [] : [...strategies],
    candidates: candidates === null ? [] : [...candidates],
    relativePos: relativePos === null ? [] : [...relativePos],
    explore: explore,
  };
}


/**
 *
 * @param pos {{x, y}}
 * @param grid {Number[][]}
 */
export function CreateCellLinkedList(pos, grid) {
  // Calculate the candidate value
  this.currentPos = {...pos};
  this.isConstant = grid[this.currentPos.y][this.currentPos.x] !== 0;
  this.candidates = [];
  this.strategies = [];
  this.current = null;
  this.relativePos = [];
  this.explore = 0;

  /**
   * Return available of the grid.
   */
  this.isCellConstant = function() {
    return this.isConstant || this.explore !== 0;
  }

  this.isUserCell = function() {
    return !this.isConstant;
  }

  this.getInitialCandidate = function(row, col){
    let candidates = Array.from({length: SUDOKU_SIZE}, (_, i) => i + 1);
    const sameRow = grid[row];
    const sameCol = grid.map(row => row[col]);

    // Same box
    const boxStartRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
    const boxStartCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
    const sameBox = [];
    for (let r = boxStartRow; r < boxStartRow + BOX_SIZE; r++) {
      for (let c = boxStartCol; c < boxStartCol + BOX_SIZE; c++) {
        sameBox.push(grid[r][c]);
      }
    }

    const excludeValue = new Set([...sameRow, ...sameCol, ...sameBox]);
    candidates = candidates.filter(candidate => !excludeValue.has(candidate));
    return candidates;
  };

  if (!this.isConstant) {
    this.candidates = this.getInitialCandidate(this.currentPos.y, this.currentPos.x);
    this.current = CreateCurrentTimeStepCell(null, 0, true,
        this.candidates);
  }

  /**
   *
   * @returns {Number|*}
   */
  this.getCurrentCell = function() {
    if (this.isConstant) return grid[this.currentPos.y][this.currentPos.x];

    if (this.explore !== 0) return this.explore;

    return this.current;
  }

  /**
   * Return strategy at current time step
   * @returns {any}
   */
  this.getStrategies = function() {
    return this.strategies;
  }

  this.resetStrategies = function() {
    this.strategies = [];
  }

  /**
   * Return relative position at current time step
   * @returns {any}
   */
  this.getRelativePos = function() {
    return this.relativePos;
  }

  this.resetRelativePos = function() {
    this.relativePos = [];
  }


  /**
   * Validate if the input number is valid
   *@param num {Number}
   */
  this.validate = function(num) {
    return this.candidates.some(candidate => candidate === num);
  }

  /**
   * Add a new state when strategies work/ decision make
   * @param newTimeStep
   * @param strategies
   */
  this.add = function(newTimeStep) {
    this.timeStep = newTimeStep;
    this.current = CreateCurrentTimeStepCell(this.current, this.timeStep,
        this.candidates.length !== 1, this.candidates, this.strategies,
        this.relativePos, this.explore);
  };

  /**
   * Return to the branch point
   * @param specificTimeStep
   */
  this.branchBack = function(specificTimeStep) {
    if (specificTimeStep < 0) {
      throw new Error('time step must bigger than zero');
    }

    if (this.isConstant) {
      return;
    }

    while (this.current.timeStep > specificTimeStep) {
      if (this.current.before === null) {
        throw new Error(`time step ${specificTimeStep} less than the value`);
      }
      this.current = this.current.before;
    }

    // Judge if strategy used in this time step
    this.strategies = this.current.timeStep === specificTimeStep ? [...this.current.strategies] : [];
    this.relativePos = this.current.timeStep === specificTimeStep ?[...this.current.relativePos] : [];
    this.explore = this.current.explore;
  };
}